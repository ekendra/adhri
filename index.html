<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Calm Word Garden</title>

  <!-- PWA -->
  <link rel="manifest" href="./manifest.webmanifest">
  <meta name="theme-color" content="#06101a">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <style>
    :root{
      --bg1:#06101a;
      --bg2:#0b2a2a;
      --card:rgba(255,255,255,.08);
      --stroke:rgba(255,255,255,.16);
      --text:#eef6ff;
      --muted:rgba(238,246,255,.75);
      --good:#39d98a;
      --bad:#ff5c5c;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    body{
      margin:0; min-height:100vh; color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 10%, #173a6b 0%, rgba(23,58,107,0) 55%),
        radial-gradient(1000px 700px at 85% 25%, #1a6b55 0%, rgba(26,107,85,0) 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      display:grid; place-items:center; padding:18px;
    }
    .wrap{ width:min(980px, 98vw); }
    .top{
      display:flex; gap:12px; flex-wrap:wrap;
      justify-content:space-between; align-items:center;
      margin-bottom:12px;
    }
    .panel{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:16px;
      padding:12px 14px;
      backdrop-filter: blur(10px);
    }
    .stats{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .tag{
      padding:6px 10px; border-radius:999px;
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.06);
      font-weight:650;
    }
    .btns{ display:flex; gap:10px; flex-wrap:wrap; }
    button{
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.10);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-weight:700;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    button.primary{
      background:rgba(57,217,138,.20);
      border-color:rgba(57,217,138,.45);
    }
    button.danger{
      background:rgba(255,92,92,.16);
      border-color:rgba(255,92,92,.35);
    }
    button:active{ transform: translateY(1px); }
    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:12px;
    }
    @media (max-width: 860px){
      .grid{ grid-template-columns: 1fr; }
    }
    .title{ font-size:1.08rem; font-weight:800; margin:0 0 6px 0; }
    .sub{ color:var(--muted); font-size:.95rem; margin:0; line-height:1.35; }
    .wordbox{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      margin-top:10px; padding:10px 12px;
      border-radius:14px; border:1px solid var(--stroke);
      background:rgba(0,0,0,.18);
    }
    .current{
      font-size:1.25rem; letter-spacing:.08em; font-weight:900;
      min-height: 1.4em; word-break: break-word;
    }
    .msg{ font-weight:700; }
    .msg.good{ color:var(--good); }
    .msg.bad{ color:var(--bad); }

    .controls{
      display:flex; gap:10px; flex-wrap:wrap;
      margin-top:10px; align-items:center; justify-content:space-between;
    }
    .controls .left, .controls .right{ display:flex; gap:10px; flex-wrap:wrap; }

    .hintline{ margin-top:8px; color:var(--muted); font-size:.92rem; line-height:1.35; }

    .wheelWrap{ display:grid; place-items:center; padding:10px; }
    canvas{
      width:min(520px, 92vw); height:auto;
      border-radius:18px; border:1px solid var(--stroke);
      background: radial-gradient(circle at 30% 20%, rgba(255,255,255,.10), rgba(0,0,0,.12));
      touch-action:none;
    }

    .list{
      display:grid; gap:8px; margin-top:10px;
      max-height: 240px; overflow:auto; padding-right:4px;
    }
    .item{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.06);
      border-radius:14px; padding:10px 12px; font-weight:700;
    }
    .item .w{ letter-spacing:.06em; }
    .item.done{ border-color: rgba(57,217,138,.45); background: rgba(57,217,138,.10); }
    .kbd{
      font-weight:800; padding:2px 8px; border-radius:10px;
      border:1px solid var(--stroke); background:rgba(255,255,255,.06);
    }

    .footerNote{ margin-top:10px; color:var(--muted); font-size:.92rem; line-height:1.35; }

    /* Leaderboard */
    .lbRow{ display:flex; justify-content:space-between; gap:10px; align-items:center; }
    .lbList{ display:grid; gap:8px; margin-top:10px; }
    .lbItem{
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      border:1px solid var(--stroke); background:rgba(255,255,255,.06);
      border-radius:14px; padding:10px 12px; font-weight:700;
    }
    .lbItem small{ color:var(--muted); font-weight:600; }

    /* Modal */
    .modalBack{
      position:fixed; inset:0; background:rgba(0,0,0,.45);
      display:none; place-items:center; padding:18px;
    }
    .modal{
      width:min(520px, 96vw);
      background:rgba(10,16,32,.92);
      border:1px solid var(--stroke);
      border-radius:16px;
      padding:14px;
      backdrop-filter: blur(12px);
    }
    input{
      width:100%;
      padding:12px 12px;
      border-radius:12px;
      border:1px solid var(--stroke);
      background:rgba(255,255,255,.08);
      color:var(--text);
      font-size:1rem;
      outline:none;
      box-sizing:border-box;
      margin-top:10px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="panel">
        <div class="stats">
          <span class="tag">Player: <span id="playerName">Guest</span></span>
          <span class="tag">Level: <span id="level">1</span></span>
          <span class="tag">Found: <span id="found">0</span>/<span id="total">0</span></span>
          <span class="tag">Stars: <span id="stars">0</span></span>
          <span class="tag">Best Streak: <span id="best">0</span></span>
        </div>
      </div>
      <div class="panel btns">
        <button class="primary" id="newLevelBtn">New Level</button>
        <button id="shuffleBtn">Shuffle Letters</button>
        <button id="hintBtn">Hint</button>
        <button id="renameBtn">Change Name</button>
        <button class="danger" id="resetBtn">Reset Progress</button>
      </div>
    </div>

    <div class="grid">
      <div class="panel">
        <p class="title">Calm Word Garden</p>
        <p class="sub">
          Make words by <b>swiping</b>, <b>tapping letters</b>, or <b>typing</b>.
          Submit with <span class="kbd">Enter</span>. Remove with <span class="kbd">Backspace</span>.
        </p>

        <div class="wordbox">
          <div class="current" id="currentWord"></div>
          <div class="msg" id="msg"></div>
        </div>

        <div class="controls">
          <div class="left">
            <button id="clearBtn">Clear</button>
            <button class="primary" id="submitBtn">Submit</button>
          </div>
          <div class="right">
            <span class="tag">Mode: <span id="mode">Touch/Type</span></span>
          </div>
        </div>
        <div class="hintline" id="hintline"></div>

        <div class="wheelWrap">
          <canvas id="wheel" width="640" height="520"></canvas>
        </div>

        <div class="footerNote" id="pwaNote"></div>
      </div>

      <div class="panel">
        <p class="title">Target Words</p>
        <p class="sub">Find all words for this level to unlock the next one.</p>
        <div class="list" id="targets"></div>

        <p class="title" style="margin-top:14px;">Leaderboard (This Device)</p>
        <p class="sub">Top scores are stored locally on this device.</p>
        <div class="lbRow" style="margin-top:10px;">
          <button id="saveScoreBtn" class="primary">Save Score</button>
          <button id="clearLbBtn" class="danger">Clear Leaderboard</button>
        </div>
        <div class="lbList" id="leaderboard"></div>
      </div>
    </div>
  </div>

  <!-- Name modal -->
  <div class="modalBack" id="nameModalBack">
    <div class="modal">
      <p class="title">Player Name</p>
      <p class="sub">Type a name for the leaderboard. Example: Aanya, Aviv, Mom.</p>
      <input id="nameInput" maxlength="18" placeholder="Enter name..." autocomplete="nickname" />
      <div class="controls" style="margin-top:12px;">
        <div class="left">
          <button id="nameCancelBtn">Cancel</button>
          <button class="primary" id="nameSaveBtn">Save</button>
        </div>
      </div>
      <div class="hintline">Privacy: name stays on this device only.</div>
    </div>
  </div>

<script>
(() => {
  /* =======================
     PWA registration
  ======================= */
  const pwaNote = document.getElementById("pwaNote");
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", async () => {
      try {
        await navigator.serviceWorker.register("./sw.js");
        pwaNote.textContent = "PWA ready: you can install this game from your browser menu (Add to Home Screen).";
      } catch {
        pwaNote.textContent = "PWA note: service worker registration failed.";
      }
    });
  } else {
    pwaNote.textContent = "PWA note: your browser does not support offline install features.";
  }

  /* =======================
     Game data
  ======================= */
  const LEVELS = [
    { letters: "G A R D E N", targets: ["GARDEN","RANGE","GRADE","ANGER","EARN","NEAR","RAN","AGE","DEN"] },
    { letters: "S T O R Y",   targets: ["STORY","SORT","ROTS","TOYS","TRY","TOY","SOT"] },
    { letters: "C L O U D",   targets: ["CLOUD","COULD","COLD","LOUD","DUO","OLD","COD"] },
    { letters: "P L A N E T", targets: ["PLANET","PLATE","PETAL","LEAPT","PANEL","LENT","TAP","NET","PAN"] },
    { letters: "F R I E N D", targets: ["FRIEND","FINED","FRIED","RINED","FIRE","RIDE","DINE","END","FIN"] },
    { letters: "M U S I C",   targets: ["MUSIC","SUM","SIM","SIC","CUM"] }
  ];
  const ALLOWED = new Set(LEVELS.flatMap(l => l.targets.map(w => w.toUpperCase())));

  /* =======================
     UI refs
  ======================= */
  const ui = {
    playerName: document.getElementById("playerName"),
    level: document.getElementById("level"),
    found: document.getElementById("found"),
    total: document.getElementById("total"),
    stars: document.getElementById("stars"),
    best: document.getElementById("best"),
    current: document.getElementById("currentWord"),
    msg: document.getElementById("msg"),
    targets: document.getElementById("targets"),
    hintline: document.getElementById("hintline"),
    mode: document.getElementById("mode"),
    leaderboard: document.getElementById("leaderboard"),

    newLevelBtn: document.getElementById("newLevelBtn"),
    shuffleBtn: document.getElementById("shuffleBtn"),
    hintBtn: document.getElementById("hintBtn"),
    renameBtn: document.getElementById("renameBtn"),
    resetBtn: document.getElementById("resetBtn"),
    clearBtn: document.getElementById("clearBtn"),
    submitBtn: document.getElementById("submitBtn"),
    saveScoreBtn: document.getElementById("saveScoreBtn"),
    clearLbBtn: document.getElementById("clearLbBtn"),

    canvas: document.getElementById("wheel"),

    nameModalBack: document.getElementById("nameModalBack"),
    nameInput: document.getElementById("nameInput"),
    nameCancelBtn: document.getElementById("nameCancelBtn"),
    nameSaveBtn: document.getElementById("nameSaveBtn"),
  };

  const ctx = ui.canvas.getContext("2d");
  const W = () => ui.canvas.width;
  const H = () => ui.canvas.height;

  /* =======================
     Storage
  ======================= */
  const storeKey = "calm_word_garden_v3";
  const lbKey = "calm_word_garden_leaderboard_v1";
  const nameKey = "calm_word_garden_player_name";

  const loadJSON = (k, fallback) => {
    try { return JSON.parse(localStorage.getItem(k) || "null") ?? fallback; }
    catch { return fallback; }
  };
  const saveJSON = (k, v) => localStorage.setItem(k, JSON.stringify(v));

  const state = loadJSON(storeKey, {
    levelIndex: 0,
    stars: 0,
    bestStreak: 0,
    currentStreak: 0,
    foundByLevel: {}
  });

  let leaderboard = loadJSON(lbKey, []); // {name, stars, level, dateISO}

  function saveState(){ saveJSON(storeKey, state); }
  function saveLeaderboard(){ saveJSON(lbKey, leaderboard); }

  /* =======================
     Player name modal
  ======================= */
  function sanitizeName(s){
    const trimmed = (s || "").trim();
    // Keep it kid-safe by allowing letters/numbers/spaces only.
    const cleaned = trimmed.replace(/[^a-zA-Z0-9 ]/g, "").slice(0, 18);
    return cleaned || "Guest";
  }
  function getPlayerName(){
    return sanitizeName(localStorage.getItem(nameKey) || "Guest");
  }
  function setPlayerName(n){
    const name = sanitizeName(n);
    localStorage.setItem(nameKey, name);
    ui.playerName.textContent = name;
  }
  function openNameModal(){
    ui.nameModalBack.style.display = "grid";
    ui.nameInput.value = getPlayerName() === "Guest" ? "" : getPlayerName();
    ui.nameInput.focus();
  }
  function closeNameModal(){
    ui.nameModalBack.style.display = "none";
  }

  ui.renameBtn.addEventListener("click", openNameModal);
  ui.nameCancelBtn.addEventListener("click", closeNameModal);
  ui.nameSaveBtn.addEventListener("click", () => {
    setPlayerName(ui.nameInput.value);
    closeNameModal();
    renderLeaderboard();
  });
  ui.nameModalBack.addEventListener("click", (e) => {
    if (e.target === ui.nameModalBack) closeNameModal();
  });

  // First run: prompt for name
  setPlayerName(getPlayerName());
  if (getPlayerName() === "Guest") {
    // Gentle prompt, not blocking gameplay
    setTimeout(openNameModal, 350);
  }

  /* =======================
     Leaderboard logic
  ======================= */
  function renderLeaderboard(){
    ui.leaderboard.innerHTML = "";
    const top = [...leaderboard]
      .sort((a,b) => (b.stars - a.stars) || (b.level - a.level))
      .slice(0, 10);

    if (!top.length){
      const empty = document.createElement("div");
      empty.className = "lbItem";
      empty.innerHTML = `<div>No scores yet.</div><small>Tap “Save Score”</small>`;
      ui.leaderboard.appendChild(empty);
      return;
    }

    top.forEach((row, idx) => {
      const div = document.createElement("div");
      div.className = "lbItem";
      const when = new Date(row.dateISO).toLocaleDateString();
      div.innerHTML = `
        <div>#${idx+1} ${row.name} <small>(Lvl ${row.level})</small></div>
        <div>${row.stars} ⭐ <small>${when}</small></div>
      `;
      ui.leaderboard.appendChild(div);
    });
  }

  function saveScoreToLeaderboard(){
    const entry = {
      name: getPlayerName(),
      stars: state.stars,
      level: state.levelIndex + 1,
      dateISO: new Date().toISOString()
    };
    leaderboard.push(entry);

    // Keep only best 30 entries to avoid unbounded growth
    leaderboard = leaderboard
      .sort((a,b) => (b.stars - a.stars) || (b.level - a.level))
      .slice(0, 30);

    saveLeaderboard();
    renderLeaderboard();
    setMessage("Score saved to leaderboard.", "good");
  }

  ui.saveScoreBtn.addEventListener("click", saveScoreToLeaderboard);
  ui.clearLbBtn.addEventListener("click", () => {
    leaderboard = [];
    saveLeaderboard();
    renderLeaderboard();
    setMessage("Leaderboard cleared.", "");
  });

  /* =======================
     Game mechanics (same as before, with tap/type/swipe)
  ======================= */
  let letters = [];
  let targets = [];
  let found = new Set();
  let hintUsed = false;

  let nodes = [];
  let path = [];
  let dragging = false;
  let pointer = { x: W()/2, y: H()/2 };

  let typedWord = "";
  let typedNodeRefs = [];

  function setMessage(text, kind) {
    ui.msg.textContent = text || "";
    ui.msg.className = "msg" + (kind ? " " + kind : "");
  }
  function setHintLine(text){ ui.hintline.textContent = text || ""; }

  function shuffleArray(arr) {
    for (let i=arr.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
  function normalizeWord(w){ return (w || "").toUpperCase().replace(/[^A-Z]/g, ""); }
  function getLevel(i){ return LEVELS[Math.max(0, Math.min(LEVELS.length-1, i))]; }

  function syncUI(){
    ui.level.textContent = String(state.levelIndex + 1);
    ui.stars.textContent = String(state.stars);
    ui.best.textContent = String(state.bestStreak);
    ui.total.textContent = String(targets.length);
    ui.found.textContent = String(found.size);
  }

  function renderTargets(){
    ui.targets.innerHTML = "";
    targets.forEach(w => {
      const row = document.createElement("div");
      row.className = "item" + (found.has(w) ? " done" : "");
      const left = document.createElement("div");
      left.className = "w";
      left.textContent = found.has(w) ? w : "•".repeat(w.length);
      const right = document.createElement("div");
      right.textContent = found.has(w) ? "✓" : "";
      row.appendChild(left);
      row.appendChild(right);
      ui.targets.appendChild(row);
    });
  }

  function layoutNodes(){
    const cx = W()/2, cy = H()/2 + 20;
    const radius = 170;
    nodes = [];
    const n = letters.length;
    for (let i=0; i<n; i++){
      const a = (Math.PI*2) * (i/n) - Math.PI/2;
      nodes.push({ x: cx + Math.cos(a) * radius, y: cy + Math.sin(a) * radius, r: 34, letter: letters[i], i });
    }
  }

  function currentWord(){
    if (path.length) return normalizeWord(path.map(idx => nodes[idx].letter).join(""));
    return normalizeWord(typedWord);
  }
  function refreshCurrentDisplay(){ ui.current.textContent = currentWord(); }

  function hitNode(x,y){
    for (const node of nodes){
      const dx = x - node.x, dy = y - node.y;
      if (Math.hypot(dx,dy) <= node.r) return node.i;
    }
    return null;
  }

  function addToPath(idx){
    if (idx === null) return;
    if (path.includes(idx)) return;
    path.push(idx);
    typedWord = "";
    typedNodeRefs = [];
    refreshCurrentDisplay();
  }

  function tapAddLetter(idx){
    if (idx === null) return;
    typedWord += nodes[idx].letter;
    typedNodeRefs.push(idx);
    path = [];
    dragging = false;
    ui.mode.textContent = "Tap/Type";
    refreshCurrentDisplay();
  }

  function backspace(){
    if (path.length){
      path.pop();
      refreshCurrentDisplay();
      return;
    }
    if (typedWord.length){
      typedWord = typedWord.slice(0, -1);
      typedNodeRefs.pop();
      refreshCurrentDisplay();
    }
  }

  function clearAll(){
    path = [];
    typedWord = "";
    typedNodeRefs = [];
    refreshCurrentDisplay();
    setMessage("", "");
  }

  function giveStars(amount){
    state.stars += amount;
    syncUI();
    saveState();
  }

  function submit(){
    const w = currentWord();
    if (!w) return;

    if (!ALLOWED.has(w)) {
      state.currentStreak = 0;
      setMessage("Not in this garden.", "bad");
      clearAll();
      saveState();
      return;
    }
    if (!targets.includes(w)) {
      state.currentStreak = 0;
      setMessage("Good word, but not a target.", "bad");
      clearAll();
      saveState();
      return;
    }
    if (found.has(w)) {
      setMessage("Already found.", "bad");
      clearAll();
      return;
    }

    found.add(w);
    state.foundByLevel[state.levelIndex] = Array.from(found);
    state.currentStreak += 1;
    state.bestStreak = Math.max(state.bestStreak, state.currentStreak);

    const base = 10;
    const bonus = Math.min(20, (w.length - 2) * 2);
    const streakBonus = Math.min(15, state.currentStreak * 2);
    const hintPenalty = hintUsed ? 4 : 0;
    const earned = Math.max(3, base + bonus + streakBonus - hintPenalty);

    giveStars(earned);
    setMessage("Nice! +" + earned + " stars", "good");
    renderTargets();
    syncUI();
    clearAll();

    if (found.size === targets.length){
      setTimeout(() => {
        setMessage("Level complete. New level unlocked.", "good");
        if (state.levelIndex < LEVELS.length - 1){
          loadLevel(state.levelIndex + 1, true);
        }
      }, 600);
    } else {
      saveState();
    }
  }

  function hint(){
    const remaining = targets.filter(w => !found.has(w));
    if (!remaining.length) return;
    hintUsed = true;
    const pick = remaining[Math.floor(Math.random()*remaining.length)];
    setHintLine("Hint: One missing target word has " + pick.length + " letters.");
    setMessage("Hint shown.", "");
  }

  function draw(){
    ctx.clearRect(0,0,W(),H());

    ctx.save();
    ctx.globalAlpha = 0.15;
    for (let i=0; i<60; i++){
      const x = (i*97)%W();
      const y = (i*57)%H();
      ctx.beginPath();
      ctx.arc(x,y, (i%3)+1, 0, Math.PI*2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
    }
    ctx.restore();

    if (path.length){
      ctx.save();
      ctx.lineWidth = 10;
      ctx.lineCap = "round";
      ctx.strokeStyle = "rgba(185,220,255,.55)";
      ctx.beginPath();
      const first = nodes[path[0]];
      ctx.moveTo(first.x, first.y);
      for (let k=1; k<path.length; k++){
        const p = nodes[path[k]];
        ctx.lineTo(p.x, p.y);
      }
      if (dragging){
        ctx.lineTo(pointer.x, pointer.y);
      }
      ctx.stroke();
      ctx.restore();
    }

    for (const node of nodes){
      const selectedSwipe = path.includes(node.i);
      const selectedTap = typedNodeRefs.includes(node.i) && !path.length;
      const selected = selectedSwipe || selectedTap;

      ctx.beginPath();
      ctx.arc(node.x, node.y, node.r, 0, Math.PI*2);
      ctx.fillStyle = selected ? "rgba(57,217,138,.20)" : "rgba(255,255,255,.10)";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = selected ? "rgba(57,217,138,.55)" : "rgba(255,255,255,.18)";
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(node.x, node.y, node.r-8, 0, Math.PI*2);
      ctx.fillStyle = selected ? "rgba(57,217,138,.12)" : "rgba(0,0,0,.15)";
      ctx.fill();

      ctx.save();
      ctx.fillStyle = "rgba(238,246,255,.95)";
      ctx.font = "900 26px system-ui, -apple-system, Segoe UI, Roboto, Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(node.letter, node.x, node.y+1);
      ctx.restore();
    }

    requestAnimationFrame(draw);
  }

  function canvasPoint(evt){
    const rect = ui.canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (ui.canvas.width / rect.width);
    const y = (evt.clientY - rect.top) * (ui.canvas.height / rect.height);
    return { x, y };
  }

  let downPoint = null;
  ui.canvas.addEventListener("pointerdown", (e) => {
    ui.canvas.setPointerCapture(e.pointerId);
    const p = canvasPoint(e);
    downPoint = p;
    dragging = true;
    pointer = p;

    const idx = hitNode(p.x, p.y);
    if (idx !== null){
      addToPath(idx);
      ui.mode.textContent = "Swipe";
      setMessage("", "");
    }
  });

  ui.canvas.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    const p = canvasPoint(e);
    pointer = p;
    const idx = hitNode(p.x, p.y);
    if (idx !== null) addToPath(idx);
  });

  ui.canvas.addEventListener("pointerup", (e) => {
    const p = canvasPoint(e);
    const moved = downPoint ? Math.hypot(p.x - downPoint.x, p.y - downPoint.y) : 999;
    const isTap = moved < 10;

    dragging = false;

    if (isTap){
      if (path.length){
        const last = path[path.length - 1];
        path = [];
        tapAddLetter(last);
      } else {
        const idx = hitNode(p.x, p.y);
        if (idx !== null) tapAddLetter(idx);
      }
      downPoint = null;
      return;
    }

    submit();
    downPoint = null;
  });

  ui.canvas.addEventListener("pointercancel", () => {
    dragging = false;
    downPoint = null;
  });

  ui.shuffleBtn.addEventListener("click", () => {
    shuffleArray(letters);
    const lvl = getLevel(state.levelIndex);
    lvl.letters = letters.join(" ");
    layoutNodes();
    setMessage("Letters shuffled.", "");
  });

  ui.hintBtn.addEventListener("click", () => hint());

  ui.newLevelBtn.addEventListener("click", () => {
    const next = (state.levelIndex + 1) % LEVELS.length;
    loadLevel(next, true);
  });

  ui.resetBtn.addEventListener("click", () => {
    localStorage.removeItem(storeKey);
    localStorage.removeItem(lbKey);
    location.reload();
  });

  ui.clearBtn.addEventListener("click", () => clearAll());
  ui.submitBtn.addEventListener("click", () => submit());

  window.addEventListener("keydown", (e) => {
    const key = e.key;

    if (key === "Enter"){ e.preventDefault(); submit(); return; }
    if (key === "Backspace"){ e.preventDefault(); backspace(); return; }
    if (key === "Escape"){ e.preventDefault(); clearAll(); return; }

    if (/^[a-zA-Z]$/.test(key)){
      const ch = key.toUpperCase();
      if (!letters.includes(ch)){
        setMessage("That letter is not on the wheel.", "bad");
        return;
      }
      if (path.length) path = [];
      ui.mode.textContent = "Type";
      typedWord += ch;
      refreshCurrentDisplay();
      setMessage("", "");
    }
  });

  function loadLevel(index, fresh=false){
    state.levelIndex = Math.max(0, Math.min(LEVELS.length-1, index));
    const lvl = getLevel(state.levelIndex);

    letters = lvl.letters.split(/\s+/).map(x => x.trim()).filter(Boolean);
    targets = lvl.targets.map(normalizeWord);

    const already = state.foundByLevel[state.levelIndex] || [];
    found = new Set(already.map(normalizeWord));

    hintUsed = false;
    dragging = false;
    pointer = { x: W()/2, y: H()/2 };
    path = [];
    typedWord = "";
    typedNodeRefs = [];

    layoutNodes();
    renderTargets();
    syncUI();
    setMessage("Make a word.", "");
    setHintLine("Input: swipe, tap letters, or type. Enter submits. Backspace removes.");
    ui.mode.textContent = "Touch/Type";
    if (fresh) saveState();
    draw();
  }

  // Boot
  renderLeaderboard();
  loadLevel(state.levelIndex, false);
  draw();
})();
</script>
</body>
</html>
